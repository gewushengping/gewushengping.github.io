<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>动态规划和最长子序列 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="动态规划的过程是：每次决策都依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。动态规划是有状态转移方程的，其实本质上就是后面的决策依赖前面的状态，在当前状态确定的时候，也就确定了后面的状态，本质上是递推的。核心就是有最优子结构，即问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，没有最优子结构也用不">
<meta property="og:type" content="article">
<meta property="og:title" content="动态规划和最长子序列">
<meta property="og:url" content="http://yoursite.com/2016/09/22/动态规划和最长子序列/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="动态规划的过程是：每次决策都依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。动态规划是有状态转移方程的，其实本质上就是后面的决策依赖前面的状态，在当前状态确定的时候，也就确定了后面的状态，本质上是递推的。核心就是有最优子结构，即问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，没有最优子结构也用不">
<meta property="og:updated_time" content="2016-09-22T07:26:20.903Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="动态规划和最长子序列">
<meta name="twitter:description" content="动态规划的过程是：每次决策都依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。动态规划是有状态转移方程的，其实本质上就是后面的决策依赖前面的状态，在当前状态确定的时候，也就确定了后面的状态，本质上是递推的。核心就是有最优子结构，即问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，没有最优子结构也用不">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-动态规划和最长子序列" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/22/动态规划和最长子序列/" class="article-date">
  <time datetime="2016-09-22T07:26:20.694Z" itemprop="datePublished">2016-09-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      动态规划和最长子序列
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>动态规划的过程是：每次决策都依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。动态规划是有状态转移方程的，其实本质上就是后面的决策依赖前面的状态，在当前状态确定的时候，也就确定了后面的状态，本质上是递推的。<br>核心就是有最优子结构，即问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，没有最优子结构也用不了动态规划。<br>重叠子问题：是降低了算法的复杂度，这里指的是相对递归来说的。重叠子问题在计算的时候应该只计算一次。子问题并不是孤立的。动态规划在最优子序列里面可以把复杂度降低到平方级别，原来是指数级别。如果没有这条性质动态规划和其他算法就没有比较 优势相对于最优子结构这里是锦上添花，没有最优子结构用不了动态规划，没有重叠子问题，动态规划和其他算法没有优势，所以这朵花很重要啊。<br>其中一篇博客上说是还有无后效性，某阶段状态一旦确定就不受这个状态以后决策的影响。某状态以后 的过程不会影响以前的而状态，只与当前的状态有关，这里感觉和最优子问题是一样的，因为如果后面的影响之前的，那之前的就不是最优子问题了。<br>另外一条就是动态规划和分治法 的区别是动态规划法求解的问题，经过分解后得到的子问题往往不是独立的（即下一个 子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。</p>
<h2 id="最优子序列和最优字串"><a href="#最优子序列和最优字串" class="headerlink" title="最优子序列和最优字串"></a>最优子序列和最优字串</h2><p>没有例子好空洞啊，最优 字串和最优子序列是动态规划的经典问题。</p>
<p>最长公共子序列定义：<br>一个字符串S，去掉零个或者多个元素所剩下的子串称为S的子序列。最长公共子序列就是寻找两个给定序列的子序列，该子序列在两个序列中以相同的顺序出现，但是不必要是连续的。</p>
<p>例如序列X=ABCBDAB，Y=BDCABA。序列BCA是X和Y的一个公共子序列，但是不是X和Y的最长公共子序列，子序列BCBA是X和Y的一个LCS，序列BDAB也是。<br>字串和子序列 的唯一区别 就是字串是要求连续，子序列不要求连续。<br>先说一下二者的动态规划解法的复杂度：最长公共字序列是时间复杂度和空间复杂度都是O（n^2）最长字串是时间复杂度是O（n^2）空间复杂度可以降低到O（n）；<br>之后先说一下动态规划的流程和最长子序列的流程。之后就可以看出最长子序列的流程对应的是哪一步.</p>
<p>###动态规划的基本求解步骤<br>动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这样就形成了决策序列。<br>（1）划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。<br>(2)确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。<br>（3）确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一个阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可以写出。但是事实上常常是反过来，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。<br> (4)寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。<br>    一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。<br>实际应用中可以按以下几个简化的步骤进行设计：<br>    （1）分析最优解的性质，并刻画其结构特征。<br>    （2）递归的定义最优解。<br>    （3）以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值<br>    （4）根据计算最优值时得到的信息，构造问题的最优解<br>    使用动态规划求解问题，最重要的就是确定动态规划的三要素：<br>    （1）问题的阶段<br>    （2）每个阶段的状态<br>    （3）从前一个阶段转化到后一个阶段之间的递推关系。<br>    递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递归可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题的来说，有递归有不可比拟的优势，这也是动态规划算法的核心之处。<br>    确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。<br>          f(n,m)=max{f(n-1,m), f(n-1,m-w[n])+P(n,m)}<br>          Xi=﹤x1，⋯，xi﹥即X序列的前i个字符 (1≤i≤m)（前缀）</p>
<p>Yj=﹤y1，⋯，yj﹥即Y序列的前j个字符 (1≤j≤n)（前缀）</p>
<p>假定Z=﹤z1，⋯，zk﹥∈LCS(X , Y)。</p>
<p>若xm=yn（最后一个字符相同），则不难用反证法证明：该字符必是X与Y的任一最长公共子序列Z（设长度为k）的最后一个字符，即有zk = xm = yn 且显然有Zk-1∈LCS(Xm-1 , Yn-1)即Z的前缀Zk-1是Xm-1与Yn-1的最长公共子序列。此时，问题化归成求Xm-1与Yn-1的LCS（LCS(X , Y)的长度等于LCS(Xm-1 , Yn-1)的长度加1）。</p>
<p>若xm≠yn，则亦不难用反证法证明：要么Z∈LCS(Xm-1, Y)，要么Z∈LCS(X , Yn-1)。由于zk≠xm与zk≠yn其中至少有一个必成立，若zk≠xm则有Z∈LCS(Xm-1 , Y)，类似的，若zk≠yn 则有Z∈LCS(X , Yn-1)。此时，问题化归成求Xm-1与Y的LCS及X与Yn-1的LCS。LCS(X , Y)的长度为：max{LCS(Xm-1 , Y)的长度, LCS(X , Yn-1)的长度}。</p>
<pre><code>由于上述当xm≠yn的情况中，求LCS(Xm-1 , Y)的长度与LCS(X , Yn-1)的长度，这两个问题不是相互独立的：两者都需要求LCS(Xm-1，Yn-1)的长度。另外两个序列的LCS中包含了两个序列的前缀的LCS，故问题具有最优子结构性质考虑用动态规划法。

也就是说，解决这个LCS问题，你要求三个方面的东西：1、LCS（Xm-1，Yn-1）+1；2、LCS（Xm-1，Y），LCS（X，Yn-1）；3、max{LCS（Xm-1，Y），LCS（X，Yn-1）}。
</code></pre><p>2.1、最长公共子序列的结构</p>
<pre><code>最长公共子序列的结构有如下表示：

设序列X=&lt;x1, x2, …, xm&gt;和Y=&lt;y1, y2, …, yn&gt;的一个最长公共子序列Z=&lt;z1, z2, …, zk&gt;，则：
</code></pre><p>若xm=yn，则zk=xm=yn且Zk-1是Xm-1和Yn-1的最长公共子序列；<br>若xm≠yn且zk≠xm ，则Z是Xm-1和Y的最长公共子序列；<br>若xm≠yn且zk≠yn ，则Z是X和Yn-1的最长公共子序列。<br>    其中Xm-1=<x1, x2,="" …,="" xm-1="">，Yn-1=<y1, y2,="" …,="" yn-1="">，Zk-1=<z1, z2,="" …,="" zk-1="">。</z1,></y1,></x1,></p>
<p>2.2、子问题的递归结构<br>    由最长公共子序列问题的最优子结构性质可知，要找出X=<x1, x2,="" …,="" xm="">和Y=<y1, y2,="" …,="" yn="">的最长公共子序列，可按以下方式递归地进行：当xm=yn时，找出Xm-1和Yn-1的最长公共子序列，然后在其尾部加上xm(=yn)即可得X和Y的一个最长公共子序列。当xm≠yn时，必须解两个子问题，即找出Xm-1和Y的一个最长公共子序列及X和Yn-1的一个最长公共子序列。这两个公共子序列中较长者即为X和Y的一个最长公共子序列。</y1,></x1,></p>
<pre><code>由此递归结构容易看到最长公共子序列问题具有子问题重叠性质。例如，在计算X和Y的最长公共子序列时，可能要计算出X和Yn-1及Xm-1和Y的最长公共子序列。而这两个子问题都包含一个公共子问题，即计算Xm-1和Yn-1的最长公共子序列。

与矩阵连乘积最优计算次序问题类似，我们来建立子问题的最优值的递归关系。用c[i,j]记录序列Xi和Yj的最长公共子序列的长度。其中Xi=&lt;x1, x2, …, xi&gt;，Yj=&lt;y1, y2, …, yj&gt;。当i=0或j=0时，空序列是Xi和Yj的最长公共子序列，故c[i,j]=0。其他情况下，由定理可建立递归关系如下：
</code></pre><p>2.3、计算最优值<br>    直接利用上节节末的递归式，我们将很容易就能写出一个计算c[i,j]的递归算法，但其计算时间是随输入长度指数增长的。由于在所考虑的子问题空间中，总共只有θ(m*n)个不同的子问题，因此，用动态规划算法自底向上地计算最优值能提高算法的效率。</p>
<pre><code>计算最长公共子序列长度的动态规划算法LCS_LENGTH(X,Y)以序列X=&lt;x1, x2, …, xm&gt;和Y=&lt;y1, y2, …, yn&gt;作为输入。输出两个数组c[0..m ,0..n]和b[1..m ,1..n]。其中c[i,j]存储Xi与Yj的最长公共子序列的长度，b[i,j]记录指示c[i,j]的值是由哪一个子问题的解达到的，这在构造最长公共子序列时要用到。最后，X和Y的最长公共子序列的长度记录于c[m,n]中。
#### c[m,n]是最优决策表
Java 实现
public static List&lt;String&gt; getLCSstring(char[] str1, char[] str2) {
    int i, j;
    int len1, len2;
    len1 = str1.length;
    len2 = str2.length;
    //公共字串和公共子序列都是自下而上计算
    int maxLen = len1 &gt; len2 ? len1 : len2; //找出长度最大的那一个
    int[] max = new int[maxLen];//int 型的数组

    int[] maxIndex = new int[maxLen];//最大的索引
    int[] c = new int[maxLen];// 把二维数组变成一维的
    List&lt;String&gt; list = new ArrayList&lt;&gt;();//String型的列表

    for (i = 0; i &lt; len2; i++) {

        for (j = len1 - 1; j &gt;= 0; j--) {

            if (str2[i] == str1[j]) {

                if ((i == 0) || (j == 0))
                    c[j] = 1;
                else
                    c[j] = c[j - 1] + 1; //相等的时候是加1
                    //c[j]只是随便一个字符串的长度
                    //从后向前扫
            }


            else {
                c[j] = 0;
            }//只要 又一次不相等就完了

            if (c[j] &gt; max[0]) {   //如果是大于那暂时只有一个是最长的,而且要把后面的清0;

                max[0] = c[j]; //max[0]是最大值
                maxIndex[0] = j; //最大值的索引这里是靠前了一个索引

                System.out.print(&quot;进去最大值最大值为&quot;+c[j]+&quot;;&quot;);
                for (int k = 1; k &lt; maxLen; k++) {
                    max[k] = 0;
                    maxIndex[k] = 0;//索引也晚了
                }//只要有一个比原来的大就清零了原来的地方

            }//上面是更新最大值
            else if (c[j] == max[0]) {   //有多个是相同长度的子串
                System.out.print(&quot;进去最大值相等&quot;+c[j]+&quot;;&quot;);
                  //已经相等了
                for (int k = 1; k &lt; maxLen; k++) {
                    if (max[k] == 0) {//只有等于0的才行不是零的之就往后走
                        max[k] = c[j];  //有多个最长的都能记录下来
                        maxIndex[k] = j; //最大值的索引
                        break;  //在后面加一个就要退出循环了
                    }

                }
            }

        }
        for(int l=0;l&lt;len1;l++) {
            System.out.print(c[l]);
        }  System.out.println();
    }

     //应该是递归还是要递归的就是子问题只计算一次
    for (j = 0; j &lt; maxLen; j++) {//这里是拼接吗
        if (max[j] &gt; 0) {

            StringBuffer sb = new StringBuffer();//向后添加Buffer
            for (i = maxIndex[j] - max[j] + 1; i &lt;= maxIndex[j]; i++) {
                sb.append(str1[i]);
            }
            String lcs = sb.toString();//添加进去的是字符串
            list.add(lcs);
        }
    }//这样就完事了 之后根本没有递归的过程这里是
    return list;
}
public static List&lt;String&gt; getLCSsequence(char[] str1, char[] str2) {
    int len1, len2;
    // 设置字符串长度
    len1 = str1.length;//个数
    len2 = str2.length;//已经是个数了
    // 构造二维数组记录子问题x[i]和y[i]的LCS的长度
    int[][] opt = new int[len1 +1][len2+1];//这里应该是不能优化的必须是mxn的空间复杂度
    System.out.print(&quot;&quot; + len2);
        for (int i = 1; i &lt;=len1; i++) {
            for (int j = 1; j &lt;= len2; j++) {
                if(str1[i-1]==str2[j-1]){//

                    opt[i][j] = opt[i-1][j-1]+ 1;
                } else  if(opt[i-1][j] &gt;= opt[i][j-1])
                {
                    opt[i][j] = opt[i-1][j];
                }
                //对应第二或者第三个性质
                else
                {
                    opt[i][j] = opt[i][j-1];

                }
            }
        }
        for (int i = 0; i &lt;=len1; i++) {
            for (int j = 0; j &lt;=len2; j++) {
                System.out.print(opt[i][j]);

            }
            System.out.println();
        }

    List&lt;String&gt; list = new ArrayList&lt;&gt;();//String型的列表
    StringBuffer sb = new StringBuffer();//向后添加Buffer
    int i = len1-1, j = len2-1;
    while(i&gt;=0 &amp;&amp; j&gt;=0)
    {   //第一次肯定都是0
        if(str1[i] == str2[j])   ///如果是斜向下标记
        {
            sb.append(str1[i]);
            i--;
            j--;
        }
        else if(opt[i+1][j] &gt; opt[i][j+1])  ///如果是斜向右标记
            j--;
        else
            i--;
    }
    String lcs = sb.reverse().toString();//添加进去的是字符串
    list.add(lcs);//终于对了
    return list;
}
</code></pre><p>参考和摘抄自：<br><a href="http://blog.csdn.net/v_JULY_v/article/details/6110269" target="_blank" rel="external">http://blog.csdn.net/v_JULY_v/article/details/6110269</a></p>
<p><a href="http://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741374.html" target="_blank" rel="external">http://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741374.html</a></p>
<p>欢迎使用 ，您可以通过==设置==里的修改模板来改变新建文章的内容。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/22/动态规划和最长子序列/" data-id="ciu9u5fhy0003m46z3oe2w9dn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法-动态规划-最长子序列，最长子串/">算法,动态规划,最长子序列，最长子串</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/09/22/文章题目/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          文章题目
        
      </div>
    </a>
  
  
    <a href="/2016/09/13/查找二叉树的最短路径/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">查找二叉树的最短路径</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/新建-模板-小书匠/">新建,模板,小书匠</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/概率与数理统计/">概率与数理统计</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法-动态规划-最长子序列，最长子串/">算法,动态规划,最长子序列，最长子串</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/新建-模板-小书匠/" style="font-size: 10px;">新建,模板,小书匠</a> <a href="/tags/概率与数理统计/" style="font-size: 10px;">概率与数理统计</a> <a href="/tags/算法-动态规划-最长子序列，最长子串/" style="font-size: 10px;">算法,动态规划,最长子序列，最长子串</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/10/14/filename/">随机变量，分布函数，概率密度函数，随机变量相等，同分布，依据概率收敛，依分布收敛，大数定律，中心极限定理</a>
          </li>
        
          <li>
            <a href="/2016/09/22/文章题目/">文章题目</a>
          </li>
        
          <li>
            <a href="/2016/09/22/动态规划和最长子序列/">动态规划和最长子序列</a>
          </li>
        
          <li>
            <a href="/2016/09/13/查找二叉树的最短路径/">查找二叉树的最短路径</a>
          </li>
        
          <li>
            <a href="/2016/09/13/算法习题/">算法习题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>